#version 300 es

//uniform vec3 light_pos_worldspace;

uniform mat4 model_mat;
uniform mat4 view_mat;
uniform mat4 projection_mat;

in vec3 position_modelspace;
in vec3 diffuse_color;
in vec3 normal_modelspace;

out vec3 frag_color;
out vec3 position_worldspace;
out vec3 normal_cameraspace;
out vec3 eye_dir_cameraspace;
out vec3 light_dir_cameraspace;

void main() {
    vec3 light_pos_worldspace = vec3(0.f, 0.f, 10.f);

    gl_Position = projection_mat * view_mat * model_mat * vec4(position_modelspace, 1.0f);

    position_worldspace = (model_mat * vec4(position_modelspace, 1.0f)).xyz;

    vec3 position_cameraspce = (view_mat * model_mat * vec4(position_modelspace, 1.0f)).xyz;
    eye_dir_cameraspace = vec3(0.f,0.f,0.f) - position_cameraspce;

    vec3 light_pos_cameraspace = (view_mat * vec4(light_pos_worldspace, 1.0f)).xyz;
    light_dir_cameraspace = light_pos_cameraspace + eye_dir_cameraspace;

    // only works if model_mat does not scale model
    normal_cameraspace = (view_mat * model_mat * vec4(normal_modelspace, 0.0f)).xyz;

    frag_color = diffuse_color;
}
#version 300 es

precision mediump float;

in vec3 frag_color;
in vec3 position_worldspace;
in vec3 normal_cameraspace;
in vec3 eye_dir_cameraspace;
in vec3 light_dir_cameraspace;

out vec3 color;

void main(void) {
    vec3 light_pos_worldspace = vec3(0.f, 0.f, 10.f);

    vec3 light_color = vec3(1.f,1.f,1.f);
    float light_power = 200.0f;

    vec3 diffuse_color = frag_color/255.f;
    vec3 ambient_color = vec3(0.2f, 0.2f, 0.2f) * diffuse_color;
    vec3 specular_color = vec3(0.1f, 0.1f, 0.1f);

    float distance = length(light_pos_worldspace - position_worldspace);

    vec3 n = normalize(normal_cameraspace);
    vec3 l = normalize(light_dir_cameraspace);

    float cos_theta = clamp(dot(n,l), 0.f, 1.f);

    vec3 eye_dir = normalize(eye_dir_cameraspace);
    vec3 reflect_dir = reflect(-l, n);

    float cos_alpha = clamp(dot(eye_dir, reflect_dir), 0.f, 1.f);

    color = ambient_color + 
        diffuse_color*light_color*cos_theta/(distance*distance) + 
        specular_color*light_color*light_power*pow(cos_alpha, 5.0f)/(distance*distance);
}